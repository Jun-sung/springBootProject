<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org"
      xmlns:sec="http://www.thymeleaf.org/extras/spring-security"
      lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title th:text="#{map.title}">SafeHome - Map</title>

  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">

  <style>
    :root {
      --navy:#1A237E;
      --navy-dark:#0D1B5E;
      --header-h: 72px;
    }
    body { background:#fcfcfc; }
    #headerSpacer { height:47px; }

    .layout-row { height: calc(100vh - var(--header-h)); }
    .layout-row > [class*="col-"] { height: 100%; }
    .layout-row > section { height: 100%; }

    #map { width:100%; height:100%; min-height:400px; }

    .sidebar {
      background:#fff;
      border-right:1px solid rgba(0,0,0,.08);
      height: 100%;
      overflow: auto;
    }
    .sidebar h5 { color:var(--navy); }
    .form-hint { font-size:.85rem; color:#6b7280; }
    .section-title { font-weight:600; margin-top:1rem; }

    .hazard-row { margin-top: .35rem; }
    .legend { font-size: .82rem; color:#6b7280; white-space: nowrap; }
    .legend-swatches { display: inline-flex; gap:4px; transform: translateY(1px); }
    .legend-swatches .sw { width:12px; height:12px; border-radius:3px; border:1px solid rgba(0,0,0,.15); }
    .legend-dot{
      width: 10px; height: 10px; border-radius: 999px;
      background: #16a34a; border: 1px solid rgba(0,0,0,.18);
      display: inline-block;
    }
  </style>
</head>

<body class="d-flex flex-column min-vh-100">
  <div th:replace="~{fragments/header :: header}"></div>
  <div id="headerSpacer" aria-hidden="true"></div>

  <main class="flex-grow-1">
    <div class="container-fluid">
      <div class="row layout-row">

        <!-- Sidebar -->
        <aside class="col-12 col-lg-3 p-3 sidebar">
          <div class="d-flex align-items-center justify-content-between mb-2">
            <h5 class="fw-bold m-0" th:text="#{map.sidebar.title}">æ¡ä»¶è¨­å®š</h5>
            <a href="/" class="btn btn-sm btn-outline-secondary" th:text="#{common.home}">Home</a>
          </div>

          <div class="form-hint mb-3" th:text="#{map.sidebar.hint}">
            åœ°å›³ã‚’ç§»å‹•/ã‚ºãƒ¼ãƒ ã™ã‚‹ã¨è‡ªå‹•ã§èª­ã¿è¾¼ã¿ã¾ã™ï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ä¿å­˜ï¼‰
          </div>

          <!-- =========================
               å»ºç‰©æ¡ä»¶ (Building filters)
               ========================= -->

          <!-- å®Ÿå–å¼•ä¾¡æ ¼ (ä¸‹é™/ä¸Šé™) -->
          <div class="sub-title mt-3" th:text="#{map.filter.priceRange}">å®Ÿå–å¼•ä¾¡æ ¼ï¼ˆä¸‡å††ï¼‰</div>

			<div class="row g-2">
			  <div class="col-12">
			    <label class="form-label small text-muted mb-1" th:text="#{map.filter.maxPrice}">ä¸Šé™</label>
			    <select id="priceMax" class="form-select">
			      <!-- ì „ì²´ -->
			      <option value="" selected th:text="#{common.all}">ALL</option>
			
			      <!-- 5,000ë§Œì—” ~ 10,000ë§Œì—” (1,000ë§Œì—” ë‹¨ìœ„) -->
			      <option value="5000">5,000<span th:text="#{man}"></span></option>   <!-- 50,000,000 å†† -->
			      <option value="6000">6,000<span th:text="#{man}"></span></option>   <!-- 60,000,000 å†† -->
			      <option value="7000">7,000<span th:text="#{man}"></span></option>   <!-- 70,000,000 å†† -->
			      <option value="8000">8,000<span th:text="#{man}"></span></option>   <!-- 80,000,000 å†† -->
			      <option value="9000">9,000<span th:text="#{man}"></span></option>   <!-- 90,000,000 å†† -->
			      <option value="10000">10,000<span th:text="#{man}"></span></option> <!-- 100,000,000 å†† -->
			
			      <!-- 10,000ë§Œì—” ì´ìƒì€ 10,000ë§Œì—” ë‹¨ìœ„ (20,000 / 30,000 / 40,000 / 50,000) -->
			      <option value="20000">20,000<span th:text="#{man}"></span></option>  <!-- 200,000,000 å†† -->
			      <option value="30000">30,000<span th:text="#{man}"></span></option>  <!-- 300,000,000 å†† -->
			      <option value="40000">40,000<span th:text="#{man}"></span></option>  <!-- 400,000,000 å†† -->
			      <option value="50000">50,000<span th:text="#{man}"></span></option>  <!-- 500,000,000 å†† -->
			
			      <!-- 50,000ë§Œì—” ì´ìƒ (sentinel) -->
			      <option value="500000001">50,000+</option>
			    </select>
			  </div>
			</div>
          <!-- å»ºç¯‰å¹´(ä»¥å†…) -->
          <div class="sub-title mt-3" th:text="#{map.filter.buildingAge}">å»ºç¯‰å¹´(ä»¥å†…)</div>

          <select id="buildingAgeMax" class="form-select">
            <option value="" selected th:text="#{common.all}">ALL</option>
            <option value="1"  th:text="#{map.age.new}">ì‹ ì¶•</option>
            <option value="5"  th:text="#{map.age.5}">5ë…„ ì´ë‚´</option>
            <option value="10" th:text="#{map.age.10}">10ë…„ ì´ë‚´</option>
            <option value="15" th:text="#{map.age.15}">15ë…„ ì´ë‚´</option>
            <option value="20" th:text="#{map.age.20}">20ë…„ ì´ë‚´</option>
            <option value="25" th:text="#{map.age.25}">25ë…„ ì´ë‚´</option>
            <option value="30" th:text="#{map.age.30}">30ë…„ ì´ë‚´</option>
            <option value="35" th:text="#{map.age.35}">35ë…„ ì´ë‚´</option>
            <option value="40" th:text="#{map.age.40}">40ë…„ ì´ë‚´</option>
            <option value="40+" th:text="#{map.age.40plus}">40ë…„ ì´ìƒ</option>
          </select>

			<!-- âœ… å¹³é¢å›³ (floor plan) -->
			<div class="sub-title mt-3">é–“å–ã‚Š</div>
			
			<div class="row g-2">
			  <div class="col-12">
			    <div class="form-check">
			      <input class="form-check-input floorplan-check" type="checkbox" value="ONE_ROOM" id="fpOneRoom">
			      <label class="form-check-label" for="fpOneRoom">ãƒ¯ãƒ³ãƒ«ãƒ¼ãƒ </label>
			    </div>
			  </div>
			
			  <div class="col-6">
			    <div class="form-check">
			      <input class="form-check-input floorplan-check" type="checkbox" value="1K_1DK_1LDK" id="fp1">
			      <label class="form-check-label" for="fp1">1K/1DK/1LDK</label>
			    </div>
			
			    <div class="form-check">
			      <input class="form-check-input floorplan-check" type="checkbox" value="2K_2DK_2LDK" id="fp2">
			      <label class="form-check-label" for="fp2">2K/2DK/2LDK</label>
			    </div>
			
			  <div class="col-6">
			    <div class="form-check">
			      <input class="form-check-input floorplan-check" type="checkbox" value="3K_3DK_3LDK" id="fp3">
			      <label class="form-check-label" for="fp3">3K/3DK/3LDK</label>
			    </div>
			
			    <div class="form-check">
			      <input class="form-check-input floorplan-check" type="checkbox" value="4K_PLUS" id="fp4plus">
			      <label class="form-check-label" for="fp4plus">4K+</label>
			    </div>
			  </div>
			</div>

          <!-- âœ… Search ë²„íŠ¼: ê±´ë¬¼ ì¡°ê±´ë§Œ ì ìš©(íŠ¸ëœì­ì…˜/ì§€ê°€) -->
          <button type="button" id="btnSearch"
                  class="btn btn-navy w-100 mt-3 fw-bold"
                  th:text="#{map.btn.search}">
            æ¤œç´¢
          </button>

          <hr class="my-3">

          <!-- =========================
               Hazard Layers (existing)
               ========================= -->
          <div class="section-title" th:text="#{map.filter.hazard}">ãƒã‚¶ãƒ¼ãƒ‰ç¨®é¡</div>

          <div class="form-check hazard-row">
            <input class="form-check-input hazard-check" type="checkbox" value="flood" id="hazardFlood">
            <label class="form-check-label d-flex align-items-center gap-2 flex-wrap" for="hazardFlood">
              <span th:text="#{hazard.flood}">æ´ªæ°´</span>
              <span class="legend" th:text="#{hazard.flood.legend}">1ã€œ6</span>
              <span class="legend-swatches" aria-hidden="true">
                <span class="sw" style="background:#cfe8ff"></span>
                <span class="sw" style="background:#9fd3ff"></span>
                <span class="sw" style="background:#5fb3ff"></span>
                <span class="sw" style="background:#2f82ff"></span>
                <span class="sw" style="background:#0b4fd6"></span>
                <span class="sw" style="background:#062a75"></span>
              </span>
            </label>
          </div>

          <div class="form-check hazard-row">
            <input class="form-check-input hazard-check" type="checkbox" value="tsunami" id="hazardTsunami">
            <label class="form-check-label d-flex align-items-center gap-2 flex-wrap" for="hazardTsunami">
              <span th:text="#{hazard.tsunami}">æ´¥æ³¢</span>
              <span class="legend" th:text="#{hazard.tsunami.legend}">æµ¸æ°´æ·±</span>
              <span class="legend-swatches" aria-hidden="true">
                <span class="sw" style="background:#f5e1ff"></span>
                <span class="sw" style="background:#e9b8ff"></span>
                <span class="sw" style="background:#d68bff"></span>
                <span class="sw" style="background:#b85cff"></span>
                <span class="sw" style="background:#8a2be2"></span>
              </span>
            </label>
          </div>

          <div class="form-check hazard-row">
            <input class="form-check-input hazard-check" type="checkbox" value="landslide" id="hazardLandslide">
            <label class="form-check-label d-flex align-items-center gap-2 flex-wrap" for="hazardLandslide">
              <span th:text="#{hazard.landslide}">åœŸç ‚ç½å®³</span>
              <span class="legend" th:text="#{hazard.landslide.legend}">é»„/èµ¤</span>
              <span class="legend-swatches" aria-hidden="true">
                <span class="sw" style="background:#facc15"></span>
                <span class="sw" style="background:#ef4444"></span>
              </span>
            </label>
          </div>

          <!-- Shelter -->
          <div class="form-check mt-2 hazard-row">
            <input class="form-check-input" type="checkbox" value="shelter" id="layerShelter">
            <label class="form-check-label d-flex align-items-center gap-2 flex-wrap" for="layerShelter">
              <span th:text="#{layer.shelter}">é¿é›£æ‰€</span>
              <span class="legend" th:text="#{layer.shelter.legend}">ã‚¢ã‚¤ã‚³ãƒ³</span>
              <span class="legend-dot" aria-hidden="true"></span>
            </label>
          </div>

          <div class="mt-3 small text-muted" id="statusText" th:text="#{map.status.ready}">Ready.</div>
        </aside>

        <!-- Map -->
        <section class="col-12 col-lg-9 p-0">
          <div id="map"></div>
        </section>

      </div>
    </div>
  </main>

  <div th:replace="~{fragments/footer :: footer}"></div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.vectorgrid@1.3.0/dist/Leaflet.VectorGrid.bundled.js"></script>

<script th:inline="javascript">
  // =========================
  // i18n (Thymeleaf -> JS)
  // =========================
  window.I18N = {
    "info.none": /*[[#{info.none}]]*/ "æƒ…å ±ãªã—",
    "structure.rc": /*[[#{structure.rc}]]*/ "RC",
    "structure.src": /*[[#{structure.src}]]*/ "SRC",
    "structure.s": /*[[#{structure.s}]]*/ "S",
    "structure.wood": /*[[#{structure.wood}]]*/ "æœ¨é€ "
  };
  
//í•´ì €ë“œ ì²´í¬ë°•ìŠ¤ ìƒíƒœ
  const hazardEnabled = {
      FLOOD: false,
      TSUNAMI: false,
      LANDSLIDE: false
  };

  function getLang() {
    const bodyLang = (document.body?.dataset?.lang || "").toLowerCase();
    if (bodyLang === "ko" || bodyLang === "ja") return bodyLang;

    const url = new URL(window.location.href);
    const q = (url.searchParams.get("lang") || "").toLowerCase();
    return (q === "ko") ? "ko" : "ja";
  }

  function t(key) {
    return (window.I18N && window.I18N[key]) ? window.I18N[key] : "æƒ…å ±ãªã—";
  }

  function escapeHtml(str) {
    return String(str)
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#39;");
  }

  function isBlank(v) {
    return v == null || String(v).trim() === "";
  }

  function formatStructure(raw, lang) {
    if (isBlank(raw)) return t("info.none");
    if (lang === "ja") return String(raw);

    const s = String(raw).trim().toUpperCase();
    if (s.includes("SRC")) return "ì² ê·¼ì² ê³¨ ì½˜í¬ë¦¬íŠ¸";
    if (s.includes("RC"))  return "ì² ê·¼ ì½˜í¬ë¦¬íŠ¸";
    if (s === "S")         return "ì² ê³¨";
    if (s.includes("W") || s.includes("WOOD") || s.includes("æœ¨")) return "ëª©ì¡°";
    return String(raw);
  }

  function formatPriceToMan(price, lang) {
    if (price == null) return t("info.none");
    const n = Number(price);
    if (!Number.isFinite(n) || n <= 0) return t("info.none");

    // DBì— ë§Œì—” ë‹¨ìœ„ë¡œ ì €ì¥ë¨ (750 = 750ä¸‡å††). / 10000 ë¶ˆí•„ìš”.
    const unit = (lang === "ko") ? "ë§Œì—”" : "ä¸‡å††";
    return n.toLocaleString() + unit;
  }

  function formatTradeYearMonth(ymRaw, lang) {
    if (ymRaw == null) return t("info.none");
    const s = String(ymRaw).trim();

    const m1 = s.match(/^(\d{4})[-\/](\d{1,2})/);
    if (m1) {
      const yy = Number(m1[1]) % 100;
      const mm = Number(m1[2]);
      return (lang === "ko") ? `${yy}ë…„ ${mm}ì›”` : `${yy}å¹´${mm}æœˆ`;
    }

    const n = Number(s.replace(/\D/g, ""));
    if (!Number.isFinite(n)) return t("info.none");

    if (n >= 100000) { // yyyymm
      const yyyy = Math.floor(n / 100);
      const mm = n % 100;
      if (mm >= 1 && mm <= 12) {
        const yy = yyyy % 100;
        return (lang === "ko") ? `${yy}ë…„ ${mm}ì›”` : `${yy}å¹´${mm}æœˆ`;
      }
    }

    if (n >= 1900 && n <= 2100) { // plain year: 2023 -> "23å¹´"
      const yy = n % 100;
      return (lang === "ko") ? `${yy}ë…„` : `${yy}å¹´`;
    }

    if (n >= 10000) { // yyyy+m or yyyy+mm
      const last2 = n % 100;
      const last1 = n % 10;

      if (last2 >= 1 && last2 <= 12) {
        const yyyy = Math.floor(n / 100);
        const yy = yyyy % 100;
        return (lang === "ko") ? `${yy}ë…„ ${last2}ì›”` : `${yy}å¹´${last2}æœˆ`;
      }
      if (last1 >= 1 && last1 <= 9) {
        const yyyy = Math.floor(n / 10);
        const yy = yyyy % 100;
        return (lang === "ko") ? `${yy}ë…„ ${last1}ì›”` : `${yy}å¹´${last1}æœˆ`;
      }
    }

    return t("info.none");
  }

  const Z_RANGE = {
		    XPT001: { min: 11, max: 15 },
		    XPT002: { min: 13, max: 15 },
		    FLOOD: { min: 14, max: 15 },
		    TSUNAMI: { min: 14, max: 15 },
		    LANDSLIDE: { min: 11, max: 15 },
		    SHELTER: { min: 11, max: 15 }
		  };

		  function inRange(z, r) {
		    return r && z >= r.min && z <= r.max;
		  }

		  // =========================
		  // Map init
		  // =========================
		  let map;
		  let markerLayer;
		  const hazardGroup = L.layerGroup();

		  const hazardLayers = {
				  FLOOD: L.layerGroup(),
				  TSUNAMI: L.layerGroup(),
				  LANDSLIDE: L.layerGroup()
				};
				const hazardLoadedTiles = {
				  FLOOD: new Set(),
				  TSUNAMI: new Set(),
				  LANDSLIDE: new Set()
				};
				
		  let lastHazardZoom = null;
		  let transactionAbort = null;
		  let currentPopup = null; // ì—´ë ¤ìˆëŠ” íŒì—… ì¶”ì 
		  let filterVersion = 0;   // í•„í„° ê²€ìƒ‰ ë²„ì „ (race condition ë°©ì§€)
		  let hazardAbort = null;
		  let shelterLayer = L.layerGroup();

		  let filtersActive = false;
		  const filters = { minPrice: null, maxPrice: null, buildingAgeMax: null, buildingYearFrom: null, floorPlanGroups: null };

		  // â€œì§€ê¸ˆ í™”ë©´ íƒ€ì¼ì„ DBì— sync í•  ë ˆì´ì–´ë“¤â€
		  // í•„ìš” ì—†ìœ¼ë©´ falseë¡œ êº¼ë„ ë¨
		  const syncTargets = {
		    XPT001: true,
		    XPT002: true
		    // SHELTER: true  // í”¼ë‚œì²˜ë¥¼ íƒ€ì¼ syncë¡œ ì²˜ë¦¬í•˜ë©´ ì—¬ê¸° ì¶”ê°€
		  };

		  function debounce(fn, wait) {
		    let t;
		    return (...args) => {
		      clearTimeout(t);
		      t = setTimeout(() => fn(...args), wait);
		    };
		  }

		  const refreshAll = debounce(() => {
		    syncEnabledLayers();     // âœ… ì¤Œ ë²”ìœ„ì— ë“¤ì–´ì˜¬ ë•Œë§Œ sync í˜¸ì¶œ
		    loadTransactions();      // âœ… DBì—ì„œ í•­ìƒ í‘œì‹œ(ë„ˆ ìš”êµ¬ì‚¬í•­)
		    loadHazardsIfEnabled();  // âœ… ì¤Œ/ì²´í¬ ì¡°ê±´ ë§Œì¡± ì‹œë§Œ í‘œì‹œ
		  }, 250);

		  init();

		  async function init() {
		    map = L.map("map");
		    markerLayer = L.layerGroup().addTo(map);
		    hazardGroup.addTo(map);

		    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
		      attribution: "&copy; OpenStreetMap contributors"
		    }).addTo(map);

		    await applyInitialRegionFromUrl();
		    fixLangLinks(); // region íŒŒë¼ë¯¸í„°ë¥¼ lang ë§í¬ì— ì£¼ì…

		    map.on("moveend zoomend", refreshAll);
		    map.on("click", onMapClick);

		    // hazard ì²´í¬ë°•ìŠ¤: hazardEnabled ìƒíƒœ ë™ê¸°í™” í›„ ë¡œë”©
		    document.querySelectorAll(".hazard-check").forEach(chk => {
		      chk.addEventListener("change", function() {
		        const type = this.value.toUpperCase(); // "flood" -> "FLOOD"
		        hazardEnabled[type] = this.checked;
		        if (!this.checked && hazardLayers[type]) {
		          // ì²´í¬ í•´ì œ ì‹œ í•´ë‹¹ ë ˆì´ì–´ ì¦‰ì‹œ ì œê±° + ìºì‹œ ì´ˆê¸°í™”
		          hazardLayers[type].clearLayers();
		          if (map.hasLayer(hazardLayers[type])) map.removeLayer(hazardLayers[type]);
		          hazardLoadedTiles[type].clear();
		        }
		        loadHazardsIfEnabled();
		      });
		    });

		    // shelter ì²´í¬ë°•ìŠ¤
		    const shelterChk = document.getElementById("layerShelter");
		    if (shelterChk) {
		      shelterChk.addEventListener("change", function() {
		        if (this.checked) {
		          loadShelterTiles();
		        } else {
		          if (shelterLayer) {
		            shelterLayer.clearLayers();
		            if (map.hasLayer(shelterLayer)) map.removeLayer(shelterLayer);
		          }
		        }
		      });
		    }

		    // ê²€ìƒ‰ ë²„íŠ¼(ê°€ê²©/ê±´ì¶•ì—°í•œë§Œ)
		    const btnSearch = document.getElementById("btnSearch");
		    if (btnSearch) {
		        btnSearch.addEventListener("click", () => {
		          // UI option values are in å†† units (10000 = 1ä¸‡å††), DB stores in ä¸‡å†† â†’ Ã·10000
		          const rawMin = parseInt(document.getElementById("priceMin")?.value || "", 10);
		          filters.minPrice = null;

		          const rawMax = parseInt(document.getElementById("priceMax")?.value || "", 10);
		          // option valueëŠ” ä¸‡å†† ë‹¨ìœ„. 50000 = "50,000ä¸‡+" sentinel â†’ null(ìƒí•œ ì—†ìŒ)
		          filters.maxPrice = Number.isFinite(rawMax) && rawMax > 0 && rawMax < 50000
		            ? rawMax : null;
		          
		          const ageRaw = document.getElementById("buildingAgeMax")?.value || "";
		          const age = parseInt(ageRaw, 10);
		          filters.buildingAgeMax = Number.isFinite(age) && age > 0 ? age : null;
		          // buildingAgeMax â†’ buildingYearFrom ë³€í™˜ (ì„œë²„ëŠ” ê±´ì¶•ì—°ë„ ê¸°ì¤€ìœ¼ë¡œ í•„í„°)
		          filters.buildingYearFrom = filters.buildingAgeMax != null
		            ? new Date().getFullYear() - filters.buildingAgeMax
		            : null;

		          // floor plan ì²´í¬ë°•ìŠ¤
		          const checkedFp = [];
		          document.querySelectorAll(".floorplan-check:checked").forEach(chk => {
		            checkedFp.push(chk.value);
		          });
		          filters.floorPlanGroups = checkedFp.length > 0 ? checkedFp : null;

		          // ê²€ìƒ‰ ì‹œ ì—´ë¦° íŒì—… ë‹«ê¸°
		          if (currentPopup) { currentPopup.remove(); currentPopup = null; }

		          // ì§„í–‰ì¤‘ì¸ fetch ì·¨ì†Œ í›„ í•„í„° ì¬ê²€ìƒ‰
		          if (transactionAbort) { transactionAbort.abort(); transactionAbort = null; }
		          filterVersion++;
		          filtersActive = true;
		          loadTransactions();
		        });
		    }

		    // ìµœì´ˆ ë¡œë“œ
		    syncEnabledLayers();
		    loadTransactions();
		    loadHazardsIfEnabled();
		  }

		  async function applyInitialRegionFromUrl() {
		    const url = new URL(window.location.href);
		    const region = url.searchParams.get("region");
		    const fallback = { lat: 35.6812, lng: 139.7671, zoom: 11 }; // Tokyo

		    if (!region) {
		      map.setView([fallback.lat, fallback.lng], fallback.zoom);
		      return;
		    }

		    try {
		      const res = await fetch(`/api/map/region-center?regionCode=${encodeURIComponent(region)}`);
		      if (!res.ok) throw new Error("region-center failed");
		      const obj = await res.json();
		      map.setView([obj.lat ?? fallback.lat, obj.lng ?? fallback.lng], 11);
		    } catch (e) {
		      console.warn("region-center fallback", e);
		      map.setView([fallback.lat, fallback.lng], fallback.zoom);
		    }
		  }

		  // =============================================
		  // Lang switch: region íŒŒë¼ë¯¸í„° ë³´ì¡´
		  // headerì˜ lang ë§í¬ì— í˜„ì¬ URLì˜ region ê°’ì„ ì£¼ì…
		  // =============================================
		  function fixLangLinks() {
		    const currentUrl = new URL(window.location.href);
		    const region = currentUrl.searchParams.get("region");
		    if (!region) return; // regionì´ ì—†ìœ¼ë©´ ê·¸ëƒ¥ header ë§í¬ ì‚¬ìš©

		    document.querySelectorAll("a.dropdown-item").forEach(a => {
		      const href = a.getAttribute("href") || "";
		      if (!href.includes("lang=")) return; // lang ë§í¬ë§Œ ì²˜ë¦¬

		      try {
		        // hrefê°€ ìƒëŒ€ê²½ë¡œì¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì ˆëŒ€ê²½ë¡œë¡œ íŒŒì‹±
		        const u = new URL(href, window.location.origin);
		        u.searchParams.set("region", region); // region ì£¼ì…/ë®ì–´ì“°ê¸°
		        a.setAttribute("href", u.pathname + "?" + u.searchParams.toString());
		      } catch (e) {
		        console.warn("[fixLangLinks] parse error", href, e);
		      }
		    });
		  }



		  // =========================
		  // Sync tile (APIë³„ ì¤Œ ì •ì±… ì ìš©)
		  // =========================
		  async function syncEnabledLayers() {
		    const zoom = map.getZoom();

		    // regionCode (ì„ íƒ) â€” ë„ˆ ë°±ì—”ë“œê°€ regionCodeë¡œ ìŠ¤ì½”í”„ ì¡ì„ ìˆ˜ë„ ìˆìœ¼ë‹ˆ ê·¸ëŒ€ë¡œ ìœ ì§€
		    const url = new URL(window.location.href);
		    const regionCode = url.searchParams.get("region") || "";

		    // ì¼œì ¸ìˆëŠ” syncTargetë§Œ í˜¸ì¶œ
		    for (const [type, enabled] of Object.entries(syncTargets)) {
		      if (!enabled) continue;

		      const range = Z_RANGE[type];
		      if (!inRange(zoom, range)) {
		        // âœ… ì¶•ì†Œ ìƒíƒœ: í˜¸ì¶œí•˜ì§€ ì•ŠìŒ (í‘œì‹œë„ ì•ˆ ë¨)
		        continue;
		      }

		      const { x, y } = getTileXYZFromCenter(map.getCenter(), zoom);

		      // âœ… typeì„ ê°™ì´ ë³´ë‚´ì„œ ì„œë²„ë„ ì–´ë–¤ APIë¥¼ syncí• ì§€ íŒë‹¨ ê°€ëŠ¥
		      const qs = new URLSearchParams();
		      qs.set("type", type);
		      qs.set("z", String(zoom));
		      qs.set("x", String(x));
		      qs.set("y", String(y));
		      if (regionCode) qs.set("regionCode", regionCode);

		      try {
		        await fetch(`/api/map/sync-tile?${qs.toString()}`);
		      } catch (e) {
		        console.warn("sync-tile failed", type, e);
		      }
		    }
		  }

		  function getTileXYZFromCenter(center, zoom) {
		    const scale = Math.pow(2, zoom);
		    const worldX = ((center.lng + 180) / 360) * scale;
		    const worldY =
		      ((1 - Math.log(Math.tan(center.lat * Math.PI / 180) +
		        1 / Math.cos(center.lat * Math.PI / 180)) / Math.PI) / 2) * scale;

		    return { x: Math.floor(worldX), y: Math.floor(worldY) };
		  }

		  // =========================
		  // Transactions (bbox -> DB only)
		  // =========================
		  async function loadTransactions() {
		    try {
		      const bbox = map.getBounds().toBBoxString(); // west,south,east,north

		      if (transactionAbort) transactionAbort.abort();
		      transactionAbort = new AbortController();

		      const params = new URLSearchParams();
		      params.set("bbox", bbox);

		      if (filtersActive) {
		        if (filters.minPrice != null)         params.set("minPrice",         String(filters.minPrice));
		        if (filters.maxPrice != null)         params.set("maxPrice",         String(filters.maxPrice));
		        if (filters.buildingYearFrom != null) params.set("buildingYearFrom", String(filters.buildingYearFrom));
		      }

		      const res = await fetch(`/api/map/transactions?${params.toString()}`, {
		        signal: transactionAbort.signal
		      });
		      if (!res.ok) throw new Error(await res.text());

		      const list = await res.json();
		      markerLayer.clearLayers();

		      if (!Array.isArray(list)) return;

		      // floor plan í´ë¼ì´ì–¸íŠ¸ í•„í„°
		      const fpGroups = (filtersActive && filters.floorPlanGroups) ? filters.floorPlanGroups : null;
		      const displayList = fpGroups ? list.filter(tr => matchFloorPlan(tr.floorPlanNameJa, fpGroups)) : list;

		      for (const tr of displayList) {
		        if (tr.lat == null || tr.lng == null) continue;
		        const buildingIcon = L.divIcon({
		          className: "",
		          html: `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="22" viewBox="0 0 18 22">
		            <rect x="1" y="6" width="16" height="15" rx="1.5" fill="#1A237E" stroke="#fff" stroke-width="1.2"/>
		            <rect x="4" y="9" width="3" height="3" rx=".5" fill="#93c5fd"/>
		            <rect x="7.5" y="9" width="3" height="3" rx=".5" fill="#93c5fd"/>
		            <rect x="11" y="9" width="3" height="3" rx=".5" fill="#93c5fd"/>
		            <rect x="4" y="14" width="3" height="3" rx=".5" fill="#93c5fd"/>
		            <rect x="7.5" y="14" width="3" height="3" rx=".5" fill="#93c5fd"/>
		            <rect x="11" y="14" width="3" height="3" rx=".5" fill="#93c5fd"/>
		            <polygon points="9,0 0,5 18,5" fill="#1565C0"/>
		          </svg>`,
		          iconSize: [18, 22],
		          iconAnchor: [9, 22],
		          popupAnchor: [0, -22]
		        });
		        const m = L.marker([tr.lat, tr.lng], { icon: buildingIcon });
		        m.addTo(markerLayer);

		        m.on("click", (ev) => {
		          if (ev?.originalEvent) L.DomEvent.stop(ev.originalEvent);
		          openTransactionPopup(tr, [tr.lat, tr.lng]);
		        });
		      }
		    } catch (e) {
		      if (e.name === "AbortError") return;
		      console.error("transactions load failed", e);
		    }
		  }

		  function openTransactionPopup(tr, latlng) {
		    const lang = getLang();

		    const addr = isBlank(tr.address) ? t("info.none") : tr.address;
		    const priceLabel = formatPriceToMan(tr.price, lang);
		    const area = (tr.area == null) ? t("info.none") : `${tr.area}ã¡`;

		    const structureLabel = formatStructure(tr.structure, lang);
		    const tradeYM = formatTradeYearMonth(tr.tradeYear, lang);
		    const buildingYear = (tr.buildingYear == null) ? t("info.none") : String(tr.buildingYear);
		    const floorPlan = isBlank(tr.floorPlanNameJa) ? t("info.none") : tr.floorPlanNameJa;

		    const html = `
		      <div style="min-width:240px">
		        <b>${escapeHtml(addr)}</b><br/><br/>
		        ğŸ’° ${escapeHtml(priceLabel)}<br/>
		        ğŸ“ ${escapeHtml(area)}<br/>
		        ğŸ  ${escapeHtml(tr.buildingType ?? "-")} / ${escapeHtml(structureLabel)}<br/>
		        ğŸ— ${escapeHtml(buildingYear)}<br/>
		        ğŸ§© ${escapeHtml(floorPlan)}<br/>
		        ğŸ—“ ${escapeHtml(tradeYM)}
		      </div>
		    `;

		    if (currentPopup) { currentPopup.remove(); }
		    currentPopup = L.popup().setLatLng(latlng).setContent(html).openOn(map);
		    map.on("popupclose", () => { currentPopup = null; });
		  }

		  // =========================
		  // Hazards (ì¤Œ ì •ì±… ì ìš©)
		  // =========================
		  function getCheckedHazards() {
		    const types = [];
		    document.querySelectorAll(".hazard-check").forEach(chk => {
		      if (chk.checked) types.push(chk.value.toUpperCase());
		    });
		    return types;
		  }
		  
		  function getTilesInBounds(bounds, zoom) {
			    const scale = Math.pow(2, zoom);
			    function lng2x(lng) {
			      return Math.floor(((lng + 180) / 360) * scale);
			    }
			    function lat2y(lat) {
			      const r = lat * Math.PI / 180;
			      return Math.floor((1 - Math.log(Math.tan(r) + 1 / Math.cos(r)) / Math.PI) / 2 * scale);
			    }
			    const xMin = lng2x(bounds.getWest());
			    const xMax = lng2x(bounds.getEast());
			    const yMin = lat2y(bounds.getNorth());
			    const yMax = lat2y(bounds.getSouth());
			    const tiles = [];
			    for (let x = xMin; x <= xMax; x++) {
			      for (let y = yMin; y <= yMax; y++) {
			        tiles.push({ x, y });
			      }
			    }
			    return tiles;
			  }
		  
		  // ============================================================
  // Floor plan ê·¸ë£¹ ë§¤ì¹­ (í´ë¼ì´ì–¸íŠ¸ í•„í„°)
  // DB floor_plan_name_ja ì˜ˆ: "2LDK", "3K", "ãƒ¯ãƒ³ãƒ«ãƒ¼ãƒ " ë“±
  // ============================================================
function matchFloorPlan(fp, groups) {
  // 1. í•„í„° ê·¸ë£¹ì´ ì„ íƒë˜ì§€ ì•Šì•˜ë‹¤ë©´ ëª¨ë“  ë§¤ë¬¼ì„ ë³´ì—¬ì¤ë‹ˆë‹¤.
  if (!groups || groups.length === 0) return true;

  // 2. í•„í„°ê°€ ì„ íƒë˜ì—ˆëŠ”ë° í‰ë©´ë„ ë°ì´í„°ê°€ ì—†ë‹¤ë©´(null) í™”ë©´ì—ì„œ ì œì™¸í•©ë‹ˆë‹¤.
  if (!fp) return false;

  // 3. ì „ê° ë¬¸ì(ï¼’, ï¼¬, ï¼¤, ï¼«)ë¥¼ ë°˜ê°(2, L, D, K)ìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
  // ì¼ë³¸ ë¶€ë™ì‚° ë°ì´í„° ì²˜ë¦¬ ì‹œ í•„ìˆ˜ì ì¸ ë‹¨ê³„ì…ë‹ˆë‹¤.
  const s = String(fp).trim()
    .replace(/[ï¼-ï¼™ï¼¡-ï¼ºï½-ï½š]/g, (m) => {
      return String.fromCharCode(m.charCodeAt(0) - 0xFEE0);
    })
    .toUpperCase();

  // 4. ë³€í™˜ëœ ë¬¸ìì—´(s)ë¡œ í•„í„°ë§ì„ ì§„í–‰í•©ë‹ˆë‹¤.
  return groups.some(group => {
    switch (group) {
      case "ONE_ROOM":
        return s === "1R" || s.includes("ãƒ¯ãƒ³ãƒ«ãƒ¼ãƒ ");
      case "1K_1DK_1LDK":
        // S(Service Room)ê°€ í¬í•¨ëœ 1SLDK ë“±ë„ í¬í•¨ë˜ë„ë¡ ë²”ìœ„ë¥¼ ë„“í˜”ìŠµë‹ˆë‹¤.
        return /^1(S)?(K|DK|LDK)$/.test(s);
      case "2K_2DK_2LDK":
        return /^2(S)?(K|DK|LDK)$/.test(s);
      case "3K_3DK_3LDK":
        return /^3(S)?(K|DK|LDK)$/.test(s);
      case "4K_PLUS": {
        const num = parseInt(s, 10);
        return !isNaN(num) && num >= 4;
      }
      default: return false;
    }
  });
}

  // ============================================================
  // Shelter tile loader
  // ============================================================
  async function loadShelterTiles() {
		    const zoom = map.getZoom();
		    if (zoom < 11) return;
		    if (!map.hasLayer(shelterLayer)) shelterLayer.addTo(map);
		    shelterLayer.clearLayers();

		    const bounds = map.getBounds();
		    const tiles = getTilesInViewport(bounds, zoom);

		    for (const { x, y } of tiles) {
		      try {
		        const res = await fetch(`/api/map/shelters?z=${zoom}&x=${x}&y=${y}`);
		        if (!res.ok) continue;
		        const geo = await res.json();
		        if (geo?.features?.length > 0) {
		          L.geoJSON(geo, {
		            pointToLayer: (f, latlng) =>
		              L.circleMarker(latlng, { radius: 5, color: "#22c55e", weight: 2, fillOpacity: 0.8 })
		          }).addTo(shelterLayer);
		        }
		      } catch (err) {
		        console.warn("[shelter] tile error", x, y, err);
		      }
		    }
		  }

  async function loadHazardsIfEnabled() {
			    const zoom = map.getZoom();
			    if (zoom < 12) return;

			    const enabledTypes = Object.entries(hazardEnabled)
			        .filter(([_, enabled]) => enabled)
			        .map(([t, _]) => t);
			    if (enabledTypes.length === 0) return;

			    // ì¤Œ ë³€ê²½ ì‹œ ìºì‹œ ì´ˆê¸°í™”
			    if (lastHazardZoom !== zoom) {
			        for (const type of enabledTypes) {
			            hazardLayers[type].clearLayers();
			            hazardLoadedTiles[type].clear();
			        }
			        lastHazardZoom = zoom;
			    }

			    // ì²´í¬ëœ ë ˆì´ì–´ ì§€ë„ì— ì¶”ê°€
			    for (const type of enabledTypes) {
			        if (!map.hasLayer(hazardLayers[type])) hazardLayers[type].addTo(map);
			    }

			    const bounds = map.getBounds();
			    const tilesToLoad = getTilesInViewport(bounds, zoom);

			    // â”€â”€ ë³‘ë ¬ fetch ëª©ë¡ ìƒì„± (ìˆœì°¨ await ì œê±°) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
			    const tasks = [];
			    for (const type of enabledTypes) {
			        const loaded = hazardLoadedTiles[type];
			        for (const { x, y } of tilesToLoad) {
			            const key = `${zoom}/${x}/${y}`;
			            if (loaded.has(key)) continue;
			            loaded.add(key); // ë‚™ê´€ì  ì„ ì  â†’ ì¤‘ë³µ ìš”ì²­ ë°©ì§€
			            tasks.push({ type, x, y, key });
			        }
			    }
			    if (tasks.length === 0) return;

			    // â”€â”€ Promise.allSettled: ëª¨ë“  íƒ€ì¼ ë™ì‹œ fetch, ì‹¤íŒ¨í•´ë„ ë‚˜ë¨¸ì§€ í‘œì‹œ â”€â”€
			    await Promise.allSettled(
			        tasks.map(({ type, x, y, key }) =>
			            fetch(`/api/map/hazard-tile?type=${type}&z=${zoom}&x=${x}&y=${y}`)
			                .then(r => { if (!r.ok) throw new Error(r.status); return r.json(); })
			                .then(geo => {
			                    if (geo?.features?.length > 0) {
			                        L.geoJSON(geo, { style: hazardStyleFn(type) })
			                          .addTo(hazardLayers[type]);
			                    }
			                })
			                .catch(err => {
			                    console.warn("[hazard] tile fail", type, x, y, err);
			                    hazardLoadedTiles[type].delete(key); // ì‹¤íŒ¨ íƒ€ì¼: ë‹¤ìŒë²ˆ ì¬ì‹œë„ í—ˆìš©
			                })
			        )
			    );
			}
		  
		  // âœ… í˜„ì¬ ë·°í¬íŠ¸ì— ë³´ì´ëŠ” ëª¨ë“  íƒ€ì¼ ë°˜í™˜
		  function getTilesInViewport(bounds, zoom) {
			    const scale = Math.pow(2, zoom);
			    function lng2x(lng) {
			        return Math.floor(((lng + 180) / 360) * scale);
			    }
			    function lat2y(lat) {
			        const r = lat * Math.PI / 180;
			        return Math.floor((1 - Math.log(Math.tan(r) + 1 / Math.cos(r)) / Math.PI) / 2 * scale);
			    }
			    const xMin = lng2x(bounds.getWest())  - 1; // 1íƒ€ì¼ ì—¬ìœ 
			    const xMax = lng2x(bounds.getEast())  + 1;
			    const yMin = lat2y(bounds.getNorth()) - 1;
			    const yMax = lat2y(bounds.getSouth()) + 1;
			    const tiles = [];
			    for (let x = xMin; x <= xMax; x++) {
			        for (let y = yMin; y <= yMax; y++) {
			            tiles.push({ x, y });
			        }
			    }
			    return tiles;
			}

		  // ==================================================
  // í™ìˆ˜ 6ë‹¨ê³„: ã‚³ãƒ¼ãƒ‰1~6 (A31_007 or rank ë“± propertyëª…)
  // ì“°ë‚˜ë¯¸ 5ë‹¨ê³„: A40_003 ë¬¸ìì—´ íŒŒì‹±
  // ì‚°ì‚¬íƒœ 2ë‹¨ê³„: è­¦æˆ’åŒºåŸŸ(yellow) / ç‰¹åˆ¥è­¦æˆ’åŒºåŸŸ(red)
  // ==================================================
  const FLOOD_COLORS = [
    "#cfe8ff", // 1: 0~0.5m
    "#9fd3ff", // 2: 0.5~3m
    "#5fb3ff", // 3: 3~5m
    "#2f82ff", // 4: 5~10m
    "#0b4fd6", // 5: 10~20m
    "#062a75"  // 6: 20mì´ìƒ
  ];
  const TSUNAMI_COLORS = [
    "#f5e1ff", // 1: 0.01~0.3m
    "#e9b8ff", // 2: 0.3~1m
    "#d68bff", // 3: 1~3m
    "#b85cff", // 4: 3~5m
    "#7c1fa0"  // 5: 5mì´ìƒ
  ];

  function getFloodColor(props) {
    // API property: "rank" (int 1-6) or "A31_007" (int) or "depth_code"
    const rank = props?.rank ?? props?.A31_007 ?? props?.depth_code
                 ?? props?.suishin_code ?? props?.Code ?? props?.code;
    const n = parseInt(rank, 10);
    if (n >= 1 && n <= 6) return FLOOD_COLORS[n - 1];
    return FLOOD_COLORS[0];
  }

  function getTsunamiColor(props) {
    // A40_003: æ–‡å­—åˆ— "3mä»¥ä¸Š ã€œ 5mæœªæº€" ãªã©
    const val = props?.A40_003 ?? props?.rank ?? props?.depth ?? "";
    const s = String(val);
    if (/5mä»¥ä¸Š/.test(s) || /5\s*m/.test(s) && parseFloat(s) >= 5) return TSUNAMI_COLORS[4];
    if (/3mä»¥ä¸Š/.test(s) || /[34]\s*m/.test(s)) return TSUNAMI_COLORS[3];
    if (/1mä»¥ä¸Š/.test(s) || /[12]\s*m/.test(s)) return TSUNAMI_COLORS[2];
    if (/0\.3mä»¥ä¸Š/.test(s) || /0\.[3-9]/.test(s)) return TSUNAMI_COLORS[1];
    // fallback by numeric rank
    const n = parseInt(props?.rank ?? props?.code ?? "1", 10);
    return TSUNAMI_COLORS[Math.min(Math.max(n - 1, 0), 4)];
  }

  function getLandslideColor(props) {
    // ç‰¹åˆ¥è­¦æˆ’åŒºåŸŸ(red) / è­¦æˆ’åŒºåŸŸ(yellow)
    const zone = props?.A26_003 ?? props?.zone_type ?? props?.type ?? props?.zonetype ?? "";
    const s = String(zone).toUpperCase();
    if (s.includes("ç‰¹åˆ¥") || s.includes("RED") || s.includes("ãƒ¬ãƒƒãƒ‰") || s === "2") {
      return "#ef4444"; // èµ¤ã‚¾ãƒ¼ãƒ³
    }
    return "#facc15"; // é»„ã‚¾ãƒ¼ãƒ³
  }

  function hazardStyleFn(type) {
	  return function(feature) {
	    const props = feature?.properties ?? {};
	    let fillColor = "transparent";

	    if (type === "FLOOD") {
	      // í™ìˆ˜: A31a_205 (1~6)
	      const level = parseInt(props.A31a_205 || props.a31a_205, 10);
	      fillColor = (level >= 1 && level <= 6) ? FLOOD_COLORS[level - 1] : "transparent";
	    } 
	    else if (type === "TSUNAMI") {
	      // ì“°ë‚˜ë¯¸: A40_003 í‚¤ë¥¼ ìš°ì„ ì ìœ¼ë¡œ ì‚¬ìš© (ë¬¸ìì—´ ë˜ëŠ” ì½”ë“œê°’)
	      fillColor = getTsunamiColor(props);
	    } 
	    else if (type === "LANDSLIDE") {
	      // ì‚°ì‚¬íƒœ: A33_002 (1,3: ì˜ë¡œìš° / 2,4: ë ˆë“œ)
	      const lsLevel = parseInt(props.A33_002 || props.a33_002, 10);
	      if (lsLevel === 1 || lsLevel === 3) {
	        fillColor = "#FFEB3B"; // Yellow Zone
	      } else if (lsLevel === 2 || lsLevel === 4) {
	        fillColor = "#F44336"; // Red Zone
	      }
	    }

	    return {
	      color: fillColor,      // í…Œë‘ë¦¬
	      weight: 1,
	      fillColor: fillColor,  // ì±„ìš°ê¸°
	      fillOpacity: 0.45,
	      opacity: 0.8
	    };
	  };
	}

	// ì“°ë‚˜ë¯¸ ì»¬ëŸ¬ ì¶”ì¶œ í•¨ìˆ˜ ë³´ì •
	function getTsunamiColor(props) {
	  // A40_003 ê°’ì„ í™•ì¸í•˜ì—¬ í…ìŠ¤íŠ¸ ë§¤ì¹­ ë˜ëŠ” ìˆ«ì ë“±ê¸‰ ì²˜ë¦¬
	  const val = props.A40_003 || props.a40_003 || "";
	  const s = String(val);

	  // 1. í…ìŠ¤íŠ¸ í¬í•¨ ì—¬ë¶€ë¡œ íŒë‹¨
	  if (s.includes("20m") || s.includes("10m")) return TSUNAMI_COLORS[4]; // 5m ì´ìƒ (ìµœìƒìœ„ ë“±ê¸‰)
	  if (s.includes("5m")) return TSUNAMI_COLORS[3];
	  if (s.includes("3m")) return TSUNAMI_COLORS[2];
	  if (s.includes("1m")) return TSUNAMI_COLORS[1];
	  if (s.includes("0.3m")) return TSUNAMI_COLORS[0];

	  // 2. ìˆ«ìë¡œë§Œ ë“¤ì–´ì˜¬ ê²½ìš°ë¥¼ ëŒ€ë¹„í•œ fallback (1~5)
	  const n = parseInt(s, 10);
	  if (!isNaN(n) && n >= 1 && n <= 5) {
	    return TSUNAMI_COLORS[n - 1];
	  }

	  return "transparent";
	}


		  // =========================
		  // Identify (ì»¨íŠ¸ë¡¤ëŸ¬ì— ë§ì¶° /transactions/near ì‚¬ìš©)
		  // =========================
		  async function onMapClick(e) {
		    try {
		      const lat = e.latlng.lat;
		      const lng = e.latlng.lng;
		      const zoom = map.getZoom();

		      const res = await fetch(`/api/map/transactions/near?lat=${lat}&lng=${lng}&z=${zoom}`, {
		        headers: { "Accept": "application/json" }
		      });

		      if (res.redirected) return;

		      const ct = res.headers.get("content-type") || "";
		      if (!ct.includes("application/json")) return;
		      if (!res.ok) return;

		      const tr = await res.json();
		      if (!tr || !tr.id) return;

		      openTransactionPopup(tr, e.latlng);
		    } catch (e2) {
		      console.error("identify failed", e2);
		    }
		  }
</script>
</body>
</html>